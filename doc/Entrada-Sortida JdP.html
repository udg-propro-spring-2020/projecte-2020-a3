<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JocDeProves</title>
    <link rel="stylesheet" href="https://stackedit.io/style.css" />
  </head>

  <body class="stackedit">
    <div class="stackedit__html">
      <h1 id="joc-de-proves">JOC DE PROVES</h1>
      <h2 id="taula-de-continguts">Taula de continguts</h2>
      <ol>
        <li>
          <a href="#tractament-de-fitxers-json"
            >Tractament de fitxers <code>JSON</code></a
          >
          <ul>
            <li><a href="#descripci%C3%B3">Descripció</a></li>
            <li>
              <a href="#demostraci%C3%B3">Demostració</a>
              <ul>
                <li><a href="#entrada">Entrada</a></li>
                <li><a href="#sortida">Sortida</a></li>
                <li>
                  <a href="#jsonparseformatexception"
                    >JSONParseFormatException</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          <a href="#partides-configurades">Partides configurades</a>
          <ul>
            <li><a href="#descripci%C3%B3-1">Descripció</a></li>
            <li><a href="#demostraci%C3%B3-1">Demostració</a></li>
          </ul>
        </li>
        <li>
          <a href="#partides-guardades">Partides guardades</a>
          <ul>
            <li><a href="#descripci%C3%B3-2">Descripció</a></li>
            <li><a href="#demostraci%C3%B3-2">Demostració</a></li>
          </ul>
        </li>
        <li>
          <a href="#funcions-del-joc">Funcions del joc</a>
          <ul>
            <li><a href="#guardar-una-partida">Guardar una partida</a></li>
            <li>
              <a href="#refent-i-desfent-moviments"
                >Refent i desfent moviments</a
              >
            </li>
            <li><a href="#taules">Taules</a></li>
          </ul>
        </li>
        <li>
          <a href="#mode-gr%C3%A0fic">Mode gràfic</a>
          <ul>
            <li><a href="#desenvolupament">Desenvolupament</a></li>
            <li>
              <a href="#integritat-interf%C3%ADcie">Integritat interfície</a>
            </li>
            <li>
              <a href="#sistema-de-navegaci%C3%B3">Sistema de navegació</a>
            </li>
          </ul>
        </li>
      </ol>
      <hr />
      <h2 id="tractament-de-fitxers-json">
        Tractament de fitxers <code>JSON</code>
      </h2>
      <h3 id="descripció">Descripció</h3>
      <p>
        Una de les parts importants del projecte consisteix en la lectura i
        escriptura de fitxers <code>JSON</code>. Per al tractament de les dades
        (d’objectes JSON a objectes del joc, i a l’inversa) es fan servir les
        classes:
      </p>
      <ul>
        <li>
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/FromJSONParserHelper.java"
            ><code>FromJSONParserHelper.java</code></a
          >: Mòdul que ens fa el <em>parse</em> d’objectes JSON als de
          l’aplicatiu.
        </li>
        <li>
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/ToJSONParserHelper.java"
            ><code>ToJSONParserHelper.java</code></a
          >: Mòdul que ens fa el <em>parse</em> d’objectes de l’aplicació a
          objectes JSON.
        </li>
        <li>
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/JSONParseFormatException.java"
            ><code>JSONParseFormatException.java</code></a
          >: Excepció pròpia llençada per la classe
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/FromJSONParserHelper.java"
            ><code>FromJSONParserHelper</code></a
          >
          quan tracta un fitxer el qual conté un error de format.
        </li>
      </ul>
      <p>
        La majoria dels errors que es donen en la lectura del fitxer provoquen
        la sortida de l’aplicació, ja que, no es podria començar el joc amb
        fitxers corruptes (per exemple, no es podria iniciar una partida que no
        conté tipus de peça). Tot seguit s’explicaran més exemples on es tenca
        l’aplicació i on es pot continuar amb l’execució.<br />
        D’altre banda, els errors tractats en l’escriptura de fitxers són, en
        gran majoria, validació d’arguments.
      </p>
      <h3 id="demostració">Demostració</h3>
      <p>
        Per demostrar el funcionament de les exepcions, s’han creat diferents
        fitxers els quals contenen probables errors d’entrada. Es poden trobar
        en
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/tree/master/src/data/file_errors_tests"
          >aquesta carpeta</a
        >
        i la descripció dels fitxers es troba
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/README.md"
          >aquí</a
        >.<br />
        Dividirem la demostració en dos grups: els errors d’<a href="#entrada"
          >entrada</a
        >
        i els errors de <a href="#sortida">sortida</a>.
      </p>
      <h4 id="entrada">Entrada</h4>
      <p>
        Quan es dona un error d’entrada el qual implica que el programa no es
        pugui executar de manera correcte i això impliqui que s’han d’acabar
        l’execució del programa, en el cas de l’interfície es mostrarà un
        <em>pop up</em>, mentre que amb el mode de cónsola es mostrarà el
        missatge. Si el tractament d’aquest error permet continuar amb una
        execució correcte del programa, per els dos modes es mostrarà un
        missatge d’error, <strong>sempre per el canal d’error</strong>.
      </p>
      <blockquote>
        <p>
          <strong>Nota</strong><br />
          En el cas de l’interfície gràfica, el joc no es carrega fins que no
          s’ha escollit el mode de partida, per tant l’error no surt fins just
          abans de començar la partida. D’altre banda, en el joc per cónsola, es
          carrega abans d’escollir el mode.
        </p>
      </blockquote>
      <p>
        Primer comprovarem el tractament d’errors en els fitxers d’entrada de
        configuració (cal seleccionar l’opció d’entrar una partida configurada)
        . Si executem els fitxers amb nom <code>config_error_X.json</code>,
        seguint l’ordre numèric i per a qualsevol mode (gràfic o cònsola), en
        aquest cas, quan ens carregui el fitxer, se’ns mostraran els següents
        errors:
      </p>
      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/config_error_1json"
            ><code>config_error_1.json</code></a
          ></em
        ><br />
        <img src="https://i.imgur.com/7nUYMfe.png" alt="Error fitxer 1" />
      </p>

      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/config_error_2.json"
            ><code>config_error_2.json</code></a
          ></em
        ><br />
        <img src="https://i.imgur.com/POSXuT6.png" alt="Error fitxer 2" />
      </p>

      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/config_error_3.json"
            ><code>config_error_3.json</code></a
          ></em
        ><br />
        <img src="https://i.imgur.com/SZrnxn6.png" alt="Error fitxer 3" />
      </p>

      <p>
        En el cas del fitxer
        <em
          ><a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/config_error_4.json"
            ><code>config_error_4.json</code></a
          ></em
        >, com que conté una peça amb moviments solapats, només es mostra el
        següent missatge d’error per cònsola:
      </p>
      <pre><code>Two movements have the same displacement vector.
The second movement won't be added.
</code></pre>
      <p>
        Seguidament, comprovarem possibles errors que ens podem trobar quan
        l’usuari ens entra un fitxer de desenvolupament de partida (cal
        seleccionar l’opció d’entrar una partida carregada). Si executem els
        fitxers amb nom <code>game_error_X.json</code>, seguint l’ordre numeric
        i per a qualsevol mode (gràfic o cònsola), en aquest cas, quan ens
        carregui el fitxer se’ns mostraran els següents errors:
      </p>
      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/game_error_1.json"
            ><code>game_error_1.json</code></a
          ></em
        ><br />
        <img
          src="https://i.imgur.com/zdG1iNr.png"
          alt="Error partida guardada 1"
        />
      </p>

      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/game_error_1.json"
            ><code>game_error_2.json</code></a
          ></em
        ><br />
        <img
          src="https://i.imgur.com/ZfKkMyE.png"
          alt="Error partida guardada 2"
        />
      </p>

      <p>
        <em
          >Imatge del fitxer d’error
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/file_errors_tests/game_error_1.json"
            ><code>game_error_3.json</code></a
          ></em
        ><br />
        <img
          src="https://i.imgur.com/RYLs6R0.png"
          alt="Error partida guardada 3"
        />
      </p>

      <blockquote>
        <p>
          <strong>Nota</strong><br />
          Es mostren només captures de pantalla del <em>pop up</em> que surt a
          la interfície gràfica. En el cas de la cònsola es mostraria el mateix
          missatge que es mostra dins del <em>pop up</em> com he anunciat abans,
          <em><strong>sempre per el canal d’error</strong></em
          >.
        </p>
      </blockquote>
      <h4 id="sortida">Sortida</h4>
      <p>
        Els errors de sortida són aquells els quals es poden provocar únicament
        quan l’usuari decideix guardar la partida, ja que es crea el fitxer
        <code>JSON</code> el qual contindrà el desenvolupament de la partida.
        Tot i que aquests errors s’haurien de provocar ínfimes vegades, per no
        dir mai, és adient tractar-los per avisar a l’usuari. En cas que aquest
        error sigui causat, s’avisarà a l’usuari que hi ha hagut un error
        guardant el fitxer, mostrant un <em>pop up</em> en el cas gràfic o un
        missatge d’error en el cas per cònsola.
      </p>
      <blockquote>
        <p>
          <strong>Nota</strong><br />
          En cas que hi hagi un error mentre s’està guardant la partida, aquesta
          no es guardarà i si s’ha creat el fitxer i s’ha començat a escriure,
          aquest es borrarà.
        </p>
      </blockquote>
      <p>
        Com he comentat a la <a href="#descripci%C3%B3">descripció</a>, els
        controls que es duen a terme a la classe
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/FromJSONParserHelper.java"
          ><code>FromJSONParserHelper</code></a
        >
        són de validacions de paràmetres, on majoritàriament es comproba si les
        referències passades per paràmetres apunten a valors <em>nulls</em>. Si
        es donés aquest cas, el missatge de sortida seria el següent:
      </p>
      <p>
        <img
          src="https://i.imgur.com/rqYpDlW.png"
          alt="Error guardar partida"
        />
      </p>
      <p>
        En el cas que s’estigui jugant per el mode de la consola, el missatge
        mostrat serà el següent:
      </p>
      <pre><code>Error on saving the game!
</code></pre>
      <h4 id="jsonparseformatexception">JSONParseFormatException</h4>
      <p>
        Els exemples mostrats són alguns dels elements de control per els quals
        es fa servir l’exepció <code>JSONParseFormatException</code>. Aquesta
        excepció està formada per un tipus i un missatge (entrat per el
        programador). S’ha intentat mantenir un nombre reduit de tipus d’expció
        i els que es poden provocar són els següents:
      </p>
      <pre><code>ERROR E1: Empty list
ERROR K1: King must exist in the game
ERROR K2: King cannot be repeated
ERROR K3: Invalig king's value
ERROR I1: Invalid number
ERROR I2: Piece name not valid
ERROR I3: Movement not valid
ERROR I4: Movement property not valid
ERROR I5: Piece type not valid
ERROR I6: Color not valid
ERROR I7: Piece promotion not valid
ERROR I8: Illegal/Repeated position
ERROR E2: End of game not valid
</code></pre>
      <blockquote>
        <p>
          <strong>Nota</strong><br />
          Cada tipus està descrit a la
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/tree/master/doc/html"
            >documentació del projecte</a
          >.
        </p>
      </blockquote>
      <h2 id="partides-configurades">Partides configurades</h2>
      <h3 id="descripció-1">Descripció</h3>
      <p>
        Una de les funcions amb les quals compte el joc és la de permetre a
        l’usuari carregar un fitxer del tipus de configuració diferent al típic
        d’escacs. Això dona a l’usuari la llibertat de modificar els moviments
        de les peces, modificar les posicions inicials, entre d’altres. Alhora,
        és font de possibles errors ja que l’usuari pot no seguir l’estil que
        s’explica a l’enunciat de fitxer de configuració de partida.<br />
        El tractament d’aquests possibles errors el trobeu a l’apartat de
        <a href="#tractament-de-fitxers-json"
          >Tractament de fitxers <code>JSON</code></a
        >.
      </p>
      <h3 id="demostració-1">Demostració</h3>
      <p>
        L’aplicació ja conté el seu propi fitxer amb les normes bàsiques dels
        escacs. A més, hem trobat adient afegir
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/modified_config.json"
          >un fitxer</a
        >
        amb una petita modificació: els jugadors començaran amb dues torres de
        més, davant les originals.<br />
        Si carreguem aquesta configuració (la qual es pot trobar a github
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/data/modified_config.json"
          ><code>data/modified_config.json</code></a
        >, a una partida per cònsola, se’ns mostrarà el següent tauler:
      </p>
      <pre><code>   +---+---+---+---+---+---+---+---+
 1 | T | C | A | D | R | A | C | T |
   +---+---+---+---+---+---+---+---+
 2 | T | P | P | P | P | P | P | T |
   +---+---+---+---+---+---+---+---+
 3 |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+
 4 |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+
 5 |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+
 6 |   |   |   |   |   |   |   |   |
   +---+---+---+---+---+---+---+---+
 7 | t | p | p | p | p | p | p | t |
   +---+---+---+---+---+---+---+---+
 8 | t | c | a | d | r | a | c | t |
   +---+---+---+---+---+---+---+---+
     a   b   c   d   e   f   g   h
</code></pre>
      <p>
        Podem veure que a les posicions a2, h2 (per les blanques) i a7, h7 (per
        les negres) tenen una torre enlloc d’un peò.
      </p>
      <blockquote>
        <p>
          <strong>NOTA</strong><br />
          Aquests mòduls també es fan servir per llegir i tractar el coneixement
          de la CPU.
        </p>
      </blockquote>
      <h2 id="partides-guardades">Partides guardades</h2>
      <h3 id="descripció-2">Descripció</h3>
      <p>
        Mentre s’està jugant la partida, una de les opcions que es dona és el
        fet de poder-la <a href="#guardar-una-partida">guardar</a> a mig fer i
        també permet guardar partides acabades (abans de sortir, sempre es
        demana si es volen guardar les partides).<br />
        Aquestes partides es trobaran a una carpeta creada al mateix directori
        on es trobi l’aplicatiu amb el nom de: <code>saved_games</code>. El
        format de les partides serà <code>.json</code> i serà del tipus de
        fitxer de desenvolupament.<br />
        Doncs, a partir d’una partida guardada, es permetrà a l’usuari
        continuar-la des del punt on es va deixar. S’haurà d’escollir el mode de
        <em>partida guardada</em> i, en el mode gràfic s’obrirà un selector de
        fitxers, mentre que al mode de cònsola s’haurà d’entrar la ubicació.
      </p>
      <blockquote>
        <p>
          <strong>NOTA</strong><br />
          En cas que es carregui una partida guardada la qual ha acabat, saltarà
          una exepció i el programa no l’acceptarà. De la mateixa manera que si
          s’entra un fitxer que no és del format correcte.
        </p>
      </blockquote>
      <h3 id="demostració-2">Demostració</h3>
      <p>
        Per a comprovar el correcte funcionament, es pot, per exemple, iniciar
        en el mode gràfic una partida normal entre dues cpus. Després d’aplicar
        un nombre determinat de torns, ens quedarà un tauler diferent a
        l’inicial. Seguit guardem la partida i escollim que no volem continuar
        jugant (en cas de mode gràfic). Això ens tornarà al menú principal i,
        ara, enlloc d’escollir el mode normal, entrarem la partida guardada que
        es troba a la carpeta <code>saved_games</code>. Doncs podrem continuar
        la partida des de lúltim punt on l’hem deixat.<br />
        Per veure’n un exemple, clica
        <a href="https://i.imgur.com/tIoa7Fu.mp4">aquí</a>.
      </p>
      <p>
        D’una partida carregada, es poden dur a terme totes les opcions: refer,
        desfer i demanar taules. Cal, però, que s’hagin efectuat moviments abans
        de guardar la partida per poder desfer, i, com és evident, no es podrà
        refer un moviment si no se n’ha desfet cap.
      </p>
      <h2 id="funcions-del-joc">Funcions del joc</h2>
      <p>
        El joc compte amb diferents opcions <em>in-game</em> algunes de les
        quals ja s’han mencionat.
      </p>
      <h3 id="guardar-una-partida">Guardar una partida</h3>
      <p>
        Una de les funcions del joc és guardar les partides en fitxers del tipus
        de desenvolupament en format <code>.json</code>. Per dur a terme aquesta
        tasca, es fa servir el mòdul
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/ToJSONParserHelper.java"
          ><code>ToJSONParserHelper.java</code></a
        >. La intenció d’aquest mòdul és tenir el màxim de genericitat possible,
        ja que hem de transformar càries classes, les quals difereixen entre sí
        (en quant a propietats, estil <code>JSON</code> pertinent…) i d’aquesta
        manera evitem tenir un codi molt extens i guanyem molta
        reutilització.<br />
        Però, per poder tenir aquesta genericitat, ha sigut necessari que, totes
        les classes que s’han de guardar en fitxers, implementin una interfície
        anomenada
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/JSON.java"
          ><code>JSON</code></a
        >. Aquesta interfície simplement compte amb un mètode
        <code>toJSON()</code> el qual demana als objectes que l’implementen,
        crein una <em>string</em> dels seus atributs en el format
        <code>JSON</code> corresponent.
      </p>
      <p>
        Per a més informació sobre la classe i la interfície, vegeu la
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/tree/master/doc/html"
          >documentació</a
        >.
      </p>
      <blockquote>
        <p>
          <strong>NOTA</strong><br />
          La classe
          <a
            href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/ToJSONParserHelper.java"
            ><code>ToJSONParserHelper.java</code></a
          >
          no només és usada per guardar fitxers de desenvolupament, sinó que
          també per fitxers de configuracions.
        </p>
      </blockquote>
      <h3 id="refent-i-desfent-moviments">Refent i desfent moviments</h3>
      <p>
        La següent opció que es dona als jugadors és la possibilitat de refer i
        desfer els moviments segons convingui. Ja he remarcat abans que no es
        pot refer un moviment si no se n’ha desfet cap.<br />
        La capacitat de poder refer o desfer moviments es controla des de la
        classe
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/GameController.java"
          ><code>GameController</code></a
        >, a més de controlar tots els aspectes logístics del joc.<br />
        Des del mode de cònsola, no s’ha de tractar res, més enllà de cridar els
        mètodes corresponents i aplicar-ho a la classe <code>Chess</code> ja que
        simplement es demana mostrar el tauler (controlat per el mateix
        <code>Chess</code>).<br />
        D’altre banda, amb el mode gràfic, cal mantenir una coherència entre el
        que passa a la classe <code>Chess</code> (manipulada a partir del
        <code>GameController</code>) i llavors aplicar-ho a la part gràfica.
      </p>
      <p>
        Alguns exemples de refer i desfer moviments es poden visualitzar aquí:
      </p>
      <ul>
        <li>
          <a href="https://i.imgur.com/tIoa7Fu.mp4"
            >Carregar una partida i desfer/refer tots els moviments</a
          >
        </li>
        <li>
          <a href="https://i.imgur.com/UJFV9Ry.mp4">Fer un enroc i desfer-lo</a>
        </li>
        <li>
          <a href="https://i.imgur.com/ts3pXmn.mp4"
            >Desfer/refer una promoció</a
          >
        </li>
      </ul>
      <h3 id="taules">Taules</h3>
      <p>
        Les taules és l’empat en els escacs. Aquest empat es pot donar per acord
        entre els jugadors, en cas de rei ofegat, taules per innació o escac
        continuu.<br />
        Les taules per innacció o escac continuu, es controlen a partir de la
        classe
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/ConsoleGame.java"
          ><code>ConsoleGame.java</code></a
        >
        (si es tracta del mode per cònsola) i la classe
        <a
          href="https://github.com/udg-propro/projecte-2020-a3/blob/master/src/UIChess.java"
          ><code>ConsoleGame.java</code></a
        >
        (si es tracta del mode gràfic). Amb l’ajuda del
        <code>GameController</code> es vigila si s’ha sobrepassat el límit i, en
        cas que afirmatiu, s’acabarà la partida com un empat.
      </p>
      <h2 id="mode-gràfic">Mode gràfic</h2>
      <h3 id="desenvolupament">Desenvolupament</h3>
      <p>
        La creació de la interfície gràfica ha sigut una de les parts que més
        temps m’ha consumit. Per una part, perquè volia crear un petit sistema
        de navegació i calia mantenir un estat consistent de l’aplicatiu. En
        segon lloc, a diferència del mode per cònsola, el mode gràfica ha
        d’aplicar els canvis a la classe <code>GameController</code> (la qual fa
        de pont entre la interfície i el <code>Chess</code>) i llavors, a partir
        dels resultats, modificar el que es mostra per pantalla.<br />
        A partir de forces variables de control (llistes per saber les peces
        mortes i en quin torn, llistes per controlar les que han reviscut quan
        s’ha fet un desfer, entre d’altres) he aconseguit mantenir un fort
        nivell d’integritat entre l’interfície i el rere fons, per així dir-ne.
      </p>
      <h3 id="integritat-interfície">Integritat interfície</h3>
      <p>
        Un dels principals problemes que he tingut alhora de controlar que, tot
        el que passés a la classe <code>Chess</code> es veiés reflectit per
        pantalla, és quan es fa un refer i desfer.
      </p>
      <p>
        Certs moviments no han de comportar un alt nivell de complexitat, ja que
        si una peça es desplaça de <em>x</em> a <em>y</em> sense tenir
        repercussions (no mata, no promociona, no provoca escacs) simplement es
        tracte d’obtenir el torn anterior i moure la peça els píxels
        corresponents.
      </p>
      <p>
        El primer problema, doncs, m’apareix quan aquest moviment ha matat una
        peça i, al desfer el moviment l’haig de <em>reviure</em>. El mateix
        passa al refer un moviment, ja que s’ha de tornar a matar aquelles peces
        que s’han <em>reviscut</em>. La solució més adient que vaig trobar és a
        partir, com he dit abans, amb llistes de control. Aquestes
        <em>llistes de control</em> senzillament em vigilen a quin torn i quina
        peça (peça gràfica, en aquest cas) ha mort. D’aquesta manera i amb
        l’ajuda de la classe <code>GameController</code> per saber en quin torn
        ens trobem, podem reviure o matar les peces corresponents.
      </p>
      <p>
        El segon problema, des del meu punt de vista, un xic més complex que els
        anteriors, és el fet de controlar quan es refà i/o desfà un torn en el
        qual hi ha hagut un enroc o una promoció.<br />
        Vaig decidir doncs, diferenciar els torns a partir de controlar-ho amb
        booleans dins la mateixa classe. Així, en cas que es tractés d’un torn
        de promoció, puc controlar que mètodes els quals no s’haurien de cridar,
        no tinguin dret a cridar-se (llençant una excepció). A més, a partir de
        diferents mètodes, puc obtenir la informació ja filtrada o mapejada. Per
        exemple, sabent que un torn en el qual hi ha una promoció es guarda de
        la següent manera en format <code>JSON</code>:
      </p>
      <pre
        class="language-json"
      ><code class="prism  language-json"><span class="token punctuation">{</span>
	<span class="token string">"torn"</span><span class="token punctuation">:</span> <span class="token string">"BLANQUES"</span><span class="token punctuation">,</span>
	<span class="token string">"origen"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
	<span class="token string">"desti"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
	<span class="token string">"resultat"</span><span class="token punctuation">:</span> <span class="token string">"PROMOCIÓ: PEO-CAVALL"</span>
<span class="token punctuation">}</span>
</code></pre>
      <p>
        Llavors, en cas que es fés un desfer a una posició <em>p</em>, hauria
        simplement de cridar el mètode <code>promotionAsPair()</code> el qual em
        retornaria una parella d’strings que contenen els noms dels tipus als
        quals s’ha fet la promoció. A més d’evitar tractar els atributs fora de
        la classe, al tenir els diferents <em>booleans de control</em>, aquesta
        funció estaria protegida només per aquells torns els quals fossin del
        tipus <em>promoció</em>.<br />
        Per tant, simplement, quan es desfà o refà un moviment, només haig
        d’interpretar els torns guardats al <code>GameController</code> per
        tractar aquest desfer o refer d’una manera o d’una altre.
      </p>
      <p>
        <img
          src="https://i.imgur.com/AurFDUY.png"
          alt="https://i.imgur.com/AurFDUY.png"
          width="430"
          height="265"
        />
      </p>
      <p>
        Un altre problema, apareix quan vull carregar una partida ja guardada.
        En aquest cas, com que tota la logística està implementada a la classe
        <code>GameController</code>, necessitava alguna manera<br />
        obtenir les peces mortes i el torn.<br />
        Vaig crear un nou mètode el qual em retorna aquesta informació ja
        tractada per tal de poder-ho guardar a la classe de la interfície.
        Llavors, des de la classe <code>UIChess</code> no haig de tractar res
        sinó fer servir el sistema ja dissenyat per tractar refers i desfers.
      </p>
      <h3 id="sistema-de-navegació">Sistema de navegació</h3>
      <p>
        Des de l’inici tenia en ment que no volia tenir una simple d’una única
        pàgina. Per sort o per desgràcia, sense haver fet mai res, no sabia on
        em posava. Tot i això, vaig dissenyar un model de navegació, si se’n pot
        dir així i a partir d’un <code>enum</code> vaig controlant en quin estat
        de la pantalla em trobo, per així automatitzar-ho.
      </p>
      <p>
        A l’inici, tenia certes variables, com els fitxers seleccionats per
        entrar coneixement a la cpu, que les anava passant per les funcions i
        això em causava funcions amb moltíssims paràmetres. Al final, la majoria
        d’informació compartida la guardo com a atributs, independentment de si
        el seu ús és totalment necessari o no (per exemple, només farem servir
        els fitxers de coneixement si, primer, es juga contra l’ordinador, i
        segon, si l’usuari els entra).
      </p>
      <p>L’esquema del sistema de navegació és el següent:</p>
      <p>
        <img
          src="https://i.imgur.com/8s7MUxI.png"
          alt="https://i.imgur.com/8s7MUxI.png"
        />
      </p>
      <p>
        Per a centrar-me en quines parts era important que constessin a
        l’<code>enum</code>, vaig dividir les parts en quines eren esencials.
        Per exemple, són esencials les parts d’escollir un mode i un tipus de
        partida (a l’esquema s’anomenen <strong>A_FASE</strong> i
        <strong>B_FASE</strong> respectivament). A partir d’aquí, per controlar
        els estats (en cas de voler tornar enrere o continuar endavant), només
        era necessari saber en quin cas havíem de moure’ns de fase.<br />
        Les <strong>SUB_FASE</strong> no són del tot necessàries i, una de les
        raons per les quals l’usuari pot voler tornar enrere, és per escollir un
        altre mode, més que no pas per escollir un altre fitxer. Per això vaig
        treure pes a aquestes fases. Alhora, simplifica molt més el codi i la
        complexitat.
      </p>
      <p>
        A partir d’aquí, simplement cal analitzar quines configuracions són
        necessàries per a cada mode, és a dir, saber quan hem de guardar els
        fitxers de coneixement i quan fer-los servir. Com que tots els inicis de
        partida segueixen el mateix patró: carregar configuració i, si n’hi ha,
        carregar desenvolupament de partida, només cal comprovar quin dels
        atributs és null (és a dir, no s’ha modificat) per fer servir un
        constructor o un altre de la classe <code>GameController</code>.
      </p>
    </div>
  </body>
</html>
